<#@ assembly name="System.Core.dll" #>
<#
	foreach( MetadataFile metadataFile in project.Metadata.FilesRecursive )
	{
		HppFileGeneration hppFileGeneration = new HppFileGeneration( this, project, cppClassesQualifier, metadataFile );
		hppFileGeneration.Output.File = metadataFile.RelativeName + ".Partial.h";
		hppFileGeneration.Output.Project = cppOutputProject;
		hppFileGeneration.Render();

		CppFileGeneration cppFileGeneration = new CppFileGeneration( this, project, metadataFile );
		cppFileGeneration.Output.File = metadataFile.RelativeName + ".Partial.cpp";
		cppFileGeneration.Output.Project = cppOutputProject;
		cppFileGeneration.Render();
	}
#>
<#+
public class HppFileGeneration : Template
{
	protected GeneratedTextTransformation		TextTransformation;
	protected metadata.MetadataProject			Project;
	protected string							CppClassesQualifier;
	protected metadata.MetadataFile				File;
	
	public HppFileGeneration( GeneratedTextTransformation textTransformation, metadata.MetadataProject project, string cppClassesQualifier, metadata.MetadataFile file )
	{
		TextTransformation = textTransformation;
		Project = project;
		CppClassesQualifier = cppClassesQualifier;
		File = file;
	}
	
	public override string TransformText()
	{
#>

// AUTOGENERATED FILE. MODIFY IT AT YOUR OWN RISK.

#ifndef <#=File.RelativeName.Replace( @"\", "_" )#>_Partial_h
#define <#=File.RelativeName.Replace( @"\", "_" )#>_Partial_h

#include "<#= File.RelativePathToProj#>Core.h"

// forward declarations from other files

<#+
		foreach( MetadataClass metadataClass in File.Content.Classes )
		{
			foreach( Member m in metadataClass.Members )
			{
				MetadataClass valueClass = null;
				if ( m is ParentReference )
					valueClass = (m as ParentReference).Type;
				if ( m is Reference )
					valueClass = (m as Reference).Type;

				if ( valueClass != null && !File.Content.Types.Contains( valueClass ) )
				{
					string qualifiedNamespace = valueClass.Parent.Parent.QualifiedNamespaceBegin;
					if ( qualifiedNamespace.Length > 0 )
					{
						WriteLine( qualifiedNamespace );
						PushIndent("\t");
					}
#>
class <#=valueClass.TypeName#>; class <#=valueClass.TypeName#>_<#= valueClass.UserDefined ? "Boxed" : "Partial" #>;
<#+
					if ( qualifiedNamespace.Length > 0 )
					{
						PopIndent();
						WriteLine( "}" );
					}
				}
			}
		}
#>

// dependencies

<#+
		var DependsOnFiles = new System.Collections.Generic.HashSet < MetadataFile >();
		foreach( MetadataClass metadataClass in File.Content.Classes )
		{
			if ( metadataClass.BaseClass != null ) 
			{
				if( !File.Content.Types.Contains( metadataClass.BaseClass ) )
					DependsOnFiles.Add( metadataClass.BaseClass.Parent.Parent );
			}

			foreach( Member m in metadataClass.Members )
			{
				metadata.Type valueType = null;
				if ( m is Collection )
					valueType = (m as Collection).Type;
				if ( m is FileStorage )
					valueType = (m as FileStorage).Type;
				if ( m is Value )
					valueType = (m as Value).Type;

				if ( valueType != null && !File.Content.Types.Contains( valueType ) )
					DependsOnFiles.Add( valueType.Parent.Parent );					
			}
		}
		foreach( MetadataFile metadataFile in DependsOnFiles )
		{
#>
#include "<#= File.RelativePathFor( metadataFile ) + metadataFile.Name #>.h"
<#+
		}
		WriteLine("");
#>
// forward declarations

<#+
		string qualifiedNamespaceBegin = File.QualifiedNamespaceBegin;
		if ( qualifiedNamespaceBegin.Length > 0 )
		{
			WriteLine( qualifiedNamespaceBegin );
			PushIndent("\t");		
		}
		foreach( MetadataClass metadataClass in File.Content.Classes )
		{
			if ( metadataClass.Namespace.Length > 0 )
				WriteLine( "namespace " + metadataClass.Namespace + "{" );
#>
class <#=metadataClass.TypeName#>; class <#=metadataClass.TypeName#>_<#= metadataClass.UserDefined ? "Boxed" : "Partial" #>;
<#+
			if ( metadataClass.Namespace.Length > 0 )
				WriteLine( "}" );
		}
		string qualifiedNamespaceEnd = File.QualifiedNamespaceEnd;
		if ( qualifiedNamespaceEnd.Length > 0 )
		{
			PopIndent();
			WriteLine( "}" );
		}
		
		WriteLine( "" );
		
		if ( qualifiedNamespaceBegin.Length > 0 )
		{
			WriteLine( qualifiedNamespaceBegin );
			PushIndent("\t");
			WriteLine( "" );
		}

		// ENUMS

		foreach( Enumeration e in File.Content.Enumerations )
		{
			if ( e.Namespace.Length > 0 )
			{
				WriteLine( "namespace " + e.Namespace );
				WriteLine( "{" );
				PushIndent("\t");
			}
#>
enum <#=e.TypeName#>
{
<#+
			foreach ( Enumerator enumerator in e.Enumerators )
				WriteLine( "\t" + enumerator.Name + " = " + enumerator.IntegralValue + "," );
#>};

class <#=e.TypeName#>_Boxed : public core::DataObject
{
public:
	<#=e.TypeName#> value;
};

<#+
			if ( e.Namespace.Length > 0 )
			{
				PopIndent();
				WriteLine( "} // namespace " + e.Namespace );
			}
		}
#>
// classes

<#+
		foreach( MetadataClass c in File.Content.ClassesSorted )
		{
			if ( c.Namespace.Length > 0 )
			{
				WriteLine( "namespace " + c.Namespace );
				WriteLine( "{" );
				PushIndent("\t");
			}
			
#>
namespace <#=c.TypeName#>_ByteStream
{
	bool <#=CppClassesQualifier#>ObjectFromByteStream( core::ByteStreamReader & stream, <#=c.QualifiedTypeNameCpp#> & dataObject );
};
<#+
			if ( c.Namespace.Length > 0 )
			{
				PopIndent();
				WriteLine( "}" );
			}
			WriteLine( "" );

			if ( c.UserDefined )
				continue;

			if ( c.Namespace.Length > 0 )
			{
				WriteLine( "namespace " + c.Namespace );
				WriteLine( "{" );
				PushIndent("\t");
			}

			Write( "class " + CppClassesQualifier + c.TypeName + "_Partial" );
			if ( c is CollectionClass )
				Write(" : public core::CollectionOf < " + (c as CollectionClass).ItemsClass.QualifiedTypeNameCpp + " * >" );
			WriteLine("");
			WriteLine( "{" );
#>
public:
	<#=c.TypeName#>_Partial();
	~<#=c.TypeName#>_Partial();
<#+
			if ( !c.Members.Empty )
				WriteLine("");
			PushIndent("\t");
			foreach( Member m in c.Members )
			{
				if ( m is Collection )
				{
					Collection collection = (Collection)m;
#>
<#=collection.Type.QualifiedTypeNameCpp#>_Partial & Get_<#=m.Name#>();
<#=collection.Type.QualifiedTypeNameCpp#>_Partial const & Get_<#=m.Name#>() const;

<#+
				}
				else if ( m is FileStorage )
				{
					FileStorage fileStorage = (FileStorage)m;
#>
<#=fileStorage.Type.QualifiedTypeNameCpp#> * Get_<#=m.Name#>() const;
void Set_<#=m.Name#>( <#=fileStorage.Type.QualifiedTypeNameCpp#> * value );

<#+
				}
				else if ( m is ParentReference )
				{
					ParentReference parentReference = (ParentReference)m;
#>
<#=parentReference.Type.QualifiedTypeNameCpp#> * Get_<#=m.Name#>() const;
void Set_<#=m.Name#>( <#=parentReference.Type.QualifiedTypeNameCpp#> * value );

<#+
				}
				else if ( m is Reference )
				{
					Reference reference = (Reference)m;
					if ( !reference.Type.IsReferenced )
						TextTransformation.Error( "Can't generate reference " + m.Name + " to non-referenced type " + reference.Type.QualifiedTypeNameCpp );			
#>
<#=reference.Type.QualifiedTypeNameCpp#> * Get_<#=m.Name#>() const;
void Set_<#=m.Name#>( <#=reference.Type.QualifiedTypeNameCpp#> * value );

<#+
				}
				else if ( m is Value )
				{
					Value value = (Value)m;
					if ( value.Type is Fundamental )
					{
#>
<#=value.Type.QualifiedTypeNameCpp#> Get_<#=m.Name#>() const;
void Set_<#=m.Name#>( <#=value.Type.QualifiedTypeNameCpp#> value );

<#+
					}
					else if ( value.Type is Enumeration )
					{
						Enumeration enumeration = (Enumeration)value.Type;
#>
<#=value.Type.QualifiedTypeNameCpp#> Get_<#=m.Name#>() const;
void Set_<#=m.Name#>( <#=value.Type.QualifiedTypeNameCpp#> value );

<#+
					}
					else if ( value.Type is MetadataClass )
					{
						MetadataClass metadataClass = (MetadataClass)value.Type;
#>
<#=value.Type.QualifiedTypeNameCpp#> const & Get_<#=m.Name#>() const;
void Set_<#=m.Name#>( <#=value.Type.QualifiedTypeNameCpp#> const & value );

<#+
					}
					else
					{
						if ( value.Type == null )
							TextTransformation.Error( "Can't generate member " + c.TypeName + "." + m.Name + " with NULL type" );
						else
							TextTransformation.Error( "Can't generate member " + c.TypeName + "." + m.Name + " with unknown type " + value.Type.TypeName + " (" + value.Type.GetType().Name + ")" );
					}
				}
			}
			PopIndent();
			
			if ( !c.Members.Empty )
			{
#>
private:
<#+			
			}
			PushIndent("\t");
			foreach( Member m in c.Members )
			{
				if ( m is Collection )
				{
					Collection collection = (Collection)m;
#>
<#=collection.Type.QualifiedTypeNameCpp#>_Partial <#=m.Name#>;
<#+
				}
				else if ( m is FileStorage )
				{
					FileStorage fileStorage = (FileStorage)m;
#>
<#=fileStorage.Type.QualifiedTypeNameCpp#> * <#=m.Name#>;
<#+
				}
				else if ( m is ParentReference )
				{
					ParentReference parentReference = (ParentReference)m;
#>
<#=parentReference.Type.QualifiedTypeNameCpp#> * <#=m.Name#>;
<#+
				}
				else if ( m is Reference )
				{
					Reference reference = (Reference)m;
					if ( !reference.Type.IsReferenced )
						TextTransformation.Error( "Can't generate reference " + m.Name + " to non-referenced type " + reference.Type.QualifiedTypeNameCpp );			
#>
<#=reference.Type.QualifiedTypeNameCpp#> * <#=m.Name#>;
<#+
				}
				else if ( m is Value )
				{
					Value value = (Value)m;
					if ( value.Type is Fundamental )
					{
#>
<#=value.Type.QualifiedTypeNameCpp#> <#=m.Name#>;
<#+
					}
					else if ( value.Type is Enumeration )
					{
						Enumeration enumeration = (Enumeration)value.Type;
#>
<#=value.Type.QualifiedTypeNameCpp#> <#=m.Name#>;
<#+
					}
					else if ( value.Type is MetadataClass )
					{
						MetadataClass metadataClass = (MetadataClass)value.Type;
						if ( value.AggregateByValue )
						{
#>
<#=value.Type.QualifiedTypeNameCpp#> <#=m.Name#>;
<#+
						}
						else
						{
#>
<#=value.Type.QualifiedTypeNameCpp#> * <#=m.Name#>;
<#+
						}
					}
					else
					{
						if ( value.Type == null )
							TextTransformation.Error( "Can't generate member " + c.TypeName + "." + m.Name + " with NULL type" );
						else
							TextTransformation.Error( "Can't generate member " + c.TypeName + "." + m.Name + " with unknown type " + value.Type.TypeName + " (" + value.Type.GetType().Name + ")" );
					}
				}
			}

			PopIndent();
			WriteLine( "};" ); // end of class declaration

			if ( c.Namespace.Length > 0 )
			{
				PopIndent();
				WriteLine( "} // namespace " + c.Namespace );
			}

			WriteLine( "" );
		}

		if ( qualifiedNamespaceEnd.Length > 0 )
		{
			PopIndent();
			WriteLine( qualifiedNamespaceEnd );
		}
#>

#endif // <#=File.RelativeName.Replace( @"\", "_" )#>_Partial_h
<#+
		return this.GenerationEnvironment.ToString();
	}
}
#>
<#+
public class CppFileGeneration : Template
{
	protected GeneratedTextTransformation		TextTransformation;
	protected metadata.MetadataProject			Project;
	protected metadata.MetadataFile				File;
	
	public CppFileGeneration( GeneratedTextTransformation textTransformation, metadata.MetadataProject project, metadata.MetadataFile file )
	{
		TextTransformation = textTransformation;
		Project = project;
		File = file;
	}
	
	public override string TransformText()
	{
#>

// AUTOGENERATED FILE. MODIFY IT AT YOUR OWN RISK.

#include "<#=File.Name#>.h"

<#+
		string qualifiedNamespaceBegin = File.QualifiedNamespaceBegin;
		if ( qualifiedNamespaceBegin.Length > 0 )
		{
			WriteLine( qualifiedNamespaceBegin );
			WriteLine( "" );
		}

		foreach( MetadataClass c in File.Content.Classes )
		{
			if ( c.Namespace.Length > 0 )
			{
				WriteLine( "namespace " + c.Namespace );
				WriteLine( "{" );
				WriteLine( "" );
			}
#>
bool <#=c.TypeName#>_ByteStream::ObjectFromByteStream( core::ByteStreamReader & stream, <#=c.QualifiedTypeNameCpp#> & dataObject )
{
<#+
				foreach( Member m in c.Members )
				{
					if ( m is Value )
					{
						Value value = (Value)m;
						if ( value.Type is Fundamental )
						{
							if ( value.Type is FundamentalByte )
							{
#>
	core::uint8 <#=value.Name#>; if ( !stream.ReadUint8( <#=value.Name#> ) ) return false;
<#+
							}
							else if ( value.Type is FundamentalBool )
							{
#>
	core::uint8 <#=value.Name#>_Byte; if ( !stream.ReadUint8( <#=value.Name#>_Byte) ) return false;
	<#=value.Type.QualifiedTypeNameCpp#> <#=value.Name#> = !!<#=value.Name#>_Byte;
<#+
							}
							else if ( value.Type is FundamentalInt )
							{
#>
	<#=value.Type.QualifiedTypeNameCpp#> <#=value.Name#>; if ( !stream.ReadInt32( <#=value.Name#> ) ) return false;
<#+
							}
							else if ( value.Type is FundamentalString )
							{
#>
	core::uint32 <#=value.Name#>_Size; if ( !stream.ReadSize( <#=value.Name#>_Size ) ) return false;
	void const * <#=value.Name#>_Bytes; if ( !stream.ReadBytes( <#=value.Name#>_Size, <#=value.Name#>_Bytes ) ) return false;
	<#=value.Type.QualifiedTypeNameCpp#> <#=value.Name#> ( (char*)<#=value.Name#>_Bytes, <#=value.Name#>_Size );
<#+
							}
							else if ( value.Type is FundamentalFloat )
							{
#>
	<#=value.Type.QualifiedTypeNameCpp#> <#=value.Name#>; if ( !stream.ReadFloat32( <#=value.Name#> ) ) return false;
<#+
							}
						}
						else if ( value.Type is Enumeration )
						{
#>
	<#=value.Type.QualifiedTypeNameCpp#> <#=value.Name#>; if ( !stream.ReadEnum( <#=value.Name#> ) ) return false;
<#+
						}
						else if ( value.Type is MetadataClass )
						{
#>
	<#=value.Type.QualifiedTypeNameCpp#> <#=value.Name#>; if ( !<#=value.Type.QualifiedTypeNameCpp#>_ByteStream::ObjectFromByteStream( stream, <#=value.Name#> ) ) return false;
<#+
						}
						
						if ( c.UserDefined )
						{
#>
	dataObject.<#=value.Name#> = <#=value.Name#>;
	
<#+
						}
						else
						{
#>
	dataObject.Set_<#=value.Name#> ( <#=value.Name#> );
	
<#+
						}
					}
				}
#>	return true;
}
<#+
			if ( c.Namespace.Length > 0 )
			{
				PopIndent();
				WriteLine( "}" );
			}			
			WriteLine( "" );

			if ( c.UserDefined )
				continue;
				
			if ( c.Namespace.Length > 0 )
			{
				WriteLine( "namespace " + c.Namespace );
				WriteLine( "{" );
				WriteLine( "" );
			}
#>

<#=c.TypeName#>_Partial::<#=c.TypeName#>_Partial()
<#+
			PushIndent("\t");
			string separator = ":";
			foreach( Member m in c.Members )
			{				
				if ( m is Collection )
				{
					Collection collection = (Collection)m;
#>
<#=separator#> <#=m.Name#>()
<#+
				}
				else if ( m is FileStorage )
				{
#>
<#=separator#> <#=m.Name#>()
<#+
				}
				else if ( m is ParentReference )
				{
#>
<#=separator#> <#=m.Name#>()
<#+
				}
				else if ( m is Reference )
				{
#>
<#=separator#> <#=m.Name#>()
<#+
				}
				else if ( m is Value )
				{
					Value value = (Value)m;
					if ( value.Type is Fundamental )
					{
#>
<#=separator#> <#=m.Name#>(<#= value.DefaultValue.Length > 0 ? value.DefaultValue : "" #>)
<#+
					}
					else if ( value.Type is Enumeration )
					{
						Enumeration enumeration = (Enumeration)value.Type;
#>
<#=separator#> <#=m.Name#>(<#= value.DefaultValue.Length > 0 ? enumeration.QualifiedNamespace + "::" + value.DefaultValue : "" #>)
<#+
					}
					else if ( value.Type is MetadataClass )
					{
						MetadataClass metadataClass = (MetadataClass)value.Type;
						if ( value.AggregateByValue )
						{
#>
<#=separator#> <#=m.Name#>()
<#+
						}
						else if ( value.IsPolymorphic )
						{
#>
<#=separator#> <#=m.Name#>()
<#+
						}
						else
						{
#>
<#=separator#> <#=m.Name#> ( CORE_NEW <#=value.Type.QualifiedTypeNameCpp#> )
<#+
						}
					}
				}
				
				separator = ",";
			}

			PopIndent();
#>
{
<#+
			PushIndent("\t");
			foreach( Member m in c.Members )
			{
				if ( m is Value )
				{
					Value value = (Value)m;
					if ( value.Type is MetadataClass )
					{
						MetadataClass metadataClass = (MetadataClass)value.Type;
						if ( value.AggregateByValue && value.DefaultValue.Length > 0 )
						{
#>
{
<#+
							PushIndent("\t");
							foreach( Member member in metadataClass.Members )
							{
								if ( member is Value && (member as Value).Type is Fundamental )
								{
#>
<#=(member as Value).Type.QualifiedTypeNameCpp#> <#=member.Name#>; <#+
								}
							}
							WriteLine( value.DefaultValue + ";" );
							foreach( Member member in metadataClass.Members )
							{
								if ( member is Value && (member as Value).Type is Fundamental )
								{
#>
<#=m.Name#>.<#=member.Name#> = <#=member.Name#>; 
<#+
								}
							}
							PopIndent();
#>
}
<#+
						}
					}
				}
			}
			PopIndent();
#>
}

<#=c.TypeName#>_Partial::~<#=c.TypeName#>_Partial()
{
<#+
			PushIndent("\t");
			foreach( Member m in c.Members )
			{				
				if ( m is Collection )
				{
					Collection collection = (Collection)m;
#>
for ( <#=collection.Type.QualifiedTypeNameCpp#>_Partial::Iterator i = <#=m.Name#>.Begin(), e = <#=m.Name#>.End(); i != e; ++i )
	CORE_DELETE *i;
<#=m.Name#>.Clear();
<#+
				}
				else if ( m is FileStorage )
				{
#>
CORE_DELETE <#=m.Name#>;
<#=m.Name#> = NULL;
<#+
				}
				else if ( m is ParentReference )
				{
#>
<#=m.Name#> = NULL;
<#+
				}
				else if ( m is Reference )
				{
#>
<#=m.Name#> = NULL;
<#+
				}
				else if ( m is Value )
				{
					Value value = (Value)m;
					if ( value.Type is MetadataClass )
					{
						MetadataClass metadataClass = (MetadataClass)value.Type;
						if ( value.IsPolymorphic || !value.AggregateByValue )
						{
#>
CORE_DELETE <#=m.Name#>;
<#=m.Name#> = NULL;
<#+
						}
					}
				}
			}
			PopIndent();
#>
}

<#+
			foreach( Member m in c.Members )
			{
				if ( m is Collection )
				{
					Collection collection = (Collection)m;
#>
<#=collection.Type.QualifiedTypeNameCpp#>_Partial & <#=c.TypeName#>_Partial::Get_<#=m.Name#>() 
{ 
	return <#=m.Name#>; 
}
<#=collection.Type.QualifiedTypeNameCpp#>_Partial const & <#=c.TypeName#>_Partial::Get_<#=m.Name#>() const 
{ 
	return <#=m.Name#>; 
}

<#+
				}
				else if ( m is FileStorage )
				{
					FileStorage fileStorage = (FileStorage)m;
#>
<#=fileStorage.Type.QualifiedTypeNameCpp#> * <#=c.TypeName#>_Partial::Get_<#=m.Name#>() const 
{ 
	return <#=m.Name#>; 
}
void <#=c.TypeName#>_Partial::Set_<#=m.Name#>( <#=fileStorage.Type.QualifiedTypeNameCpp#> * value ) 
{ 
	<#=m.Name#> = value; 
}

<#+
				}
				else if ( m is ParentReference )
				{
					ParentReference parentReference = (ParentReference)m;
#>
<#=parentReference.Type.QualifiedTypeNameCpp#> * <#=c.TypeName#>_Partial::Get_<#=m.Name#>() const 
{ 
	return <#=m.Name#>; 
}
void <#=c.TypeName#>_Partial::Set_<#=m.Name#>( <#=parentReference.Type.QualifiedTypeNameCpp#> * value ) 
{ 
	<#=m.Name#> = value; 
}

<#+
				}
				else if ( m is Reference )
				{
					Reference reference = (Reference)m;
					if ( !reference.Type.IsReferenced )
						TextTransformation.Error( "Can't generate reference " + m.Name + " to non-referenced type " + reference.Type.QualifiedTypeNameCpp );			
#>
<#=reference.Type.QualifiedTypeNameCpp#> * <#=c.TypeName#>_Partial::Get_<#=m.Name#>() const 
{ 
	return <#=m.Name#>; 
}
void <#=c.TypeName#>_Partial::Set_<#=m.Name#>( <#=reference.Type.QualifiedTypeNameCpp#> * value ) 
{ 
	<#=m.Name#> = value; 
}

<#+
				}
				else if ( m is Value )
				{
					Value value = (Value)m;
					if ( value.Type is Fundamental )
					{
#>
<#=value.Type.QualifiedTypeNameCpp#> <#=c.TypeName#>_Partial::Get_<#=m.Name#>() const 
{ 
	return <#=m.Name#>; 
}
void <#=c.TypeName#>_Partial::Set_<#=m.Name#>( <#=value.Type.QualifiedTypeNameCpp#> value ) 
{ 
	<#=m.Name#> = value; 
}

<#+
					}
					else if ( value.Type is Enumeration )
					{
						Enumeration enumeration = (Enumeration)value.Type;
#>
<#=value.Type.QualifiedTypeNameCpp#> <#=c.TypeName#>_Partial::Get_<#=m.Name#>() const 
{ 
	return <#=m.Name#>; 
}
void <#=c.TypeName#>_Partial::Set_<#=m.Name#>( <#=value.Type.QualifiedTypeNameCpp#> value ) 
{ 
	<#=m.Name#> = value; 
}

<#+
					}
					else if ( value.Type is MetadataClass )
					{
						MetadataClass metadataClass = (MetadataClass)value.Type;
						if ( value.AggregateByValue )
						{
#>
<#=value.Type.QualifiedTypeNameCpp#> const & <#=c.TypeName#>_Partial::Get_<#=m.Name#>() const 
{ 
	return <#=m.Name#>; 
}
void <#=c.TypeName#>_Partial::Set_<#=m.Name#>( <#=value.Type.QualifiedTypeNameCpp#> const & value ) 
{ 
	<#=m.Name#> = value; 
}

<#+
						}
						else
						{
#>
<#=value.Type.QualifiedTypeNameCpp#> const & <#=c.TypeName#>_Partial::Get_<#=m.Name#>() const 
{ 
	CORE_ASSERT(<#=m.Name#>); 
	return *<#=m.Name#>; 
}
void <#=c.TypeName#>_Partial::Set_<#=m.Name#>( <#=value.Type.QualifiedTypeNameCpp#> const & value ) 
{ 
	CORE_ASSERT(<#=m.Name#>); 
	*<#=m.Name#> = value; 
}

<#+
						}
					}
				}
			}

			if ( c.Namespace.Length > 0 )
			{
				WriteLine( "" );
				WriteLine( "} // namespace " + c.Namespace );
			}

			WriteLine( "" );
		}

		string qualifiedNamespaceEnd = File.QualifiedNamespaceEnd;
		if ( qualifiedNamespaceEnd.Length > 0 )
		{
			WriteLine( qualifiedNamespaceEnd );
		}
	}
}
#>
