<#@ assembly name="System.Core.dll" #>
<#
	{
		foreach( MetadataFile metadataFile in project.Metadata.FilesRecursive )
		{
			UcDbHppFileGeneration hppFileGeneration = new UcDbHppFileGeneration( this, project, cppClassesQualifier, metadataFile );
			hppFileGeneration.Output.File = metadataFile.RelativeName + ".h";
			hppFileGeneration.Output.Project = cppOutputProject;
			hppFileGeneration.Render();

			UcDbCppFileGeneration cppFileGeneration = new UcDbCppFileGeneration( this, project, cppClassesQualifier, metadataFile );
			cppFileGeneration.Output.File = metadataFile.RelativeName + ".cpp";
			cppFileGeneration.Output.Project = cppOutputProject;
			cppFileGeneration.Render();
		}
	}
#>
<#+
public class UcDbHppFileGeneration : Template
{
	protected GeneratedTextTransformation		TextTransformation;
	protected metadata.MetadataProject			Project;
	protected string							CppClassesQualifier;
	protected metadata.MetadataFile				File;
	
	public UcDbHppFileGeneration( GeneratedTextTransformation textTransformation, metadata.MetadataProject project, string cppClassesQualifier, metadata.MetadataFile file )
	{
		TextTransformation = textTransformation;
		Project = project;
		CppClassesQualifier = cppClassesQualifier;
		File = file;
	}
	
	public override string TransformText()
	{
#>

// AUTOGENERATED FILE. MODIFY IT AT YOUR OWN RISK.

#ifndef <#=File.RelativeName.Replace( @"\", "_" )#>_UcDb_h
#define <#=File.RelativeName.Replace( @"\", "_" )#>_UcDb_h

#include "<#= File.RelativePathToProj#>Config.h"
#include "<#= File.RelativePathToProj#>Core.h"

// forward declarations from other files

<#+
		foreach( MetadataClass metadataClass in File.Content.Classes )
		{
			foreach( Member m in metadataClass.Members )
			{
				MetadataClass valueClass = null;
				if ( m is ParentReference )
					valueClass = (m as ParentReference).Type;
				if ( m is Reference )
					valueClass = (m as Reference).Type;

				if ( valueClass != null && !File.Content.Types.Contains( valueClass ) )
				{
					string qualifiedNamespace = valueClass.Parent.Parent.QualifiedNamespaceBegin;
					if ( qualifiedNamespace.Length > 0 )
					{
						WriteLine( qualifiedNamespace );
						PushIndent("\t");
					}
#>
class <#=valueClass.TypeName#>;
<#+
					if ( valueClass.UserDefined )
					{
#>
class <#=valueClass.TypeName#>_Boxed;
<#+
					}
					if ( qualifiedNamespace.Length > 0 )
					{
						PopIndent();
						WriteLine( "}" );
					}
				}
			}
		}
#>

// dependencies

<#+
		var DependsOnFiles = new System.Collections.Generic.HashSet < MetadataFile >();
		foreach( MetadataClass metadataClass in File.Content.Classes )
		{
			if ( metadataClass.BaseClass != null ) 
			{
				if( !File.Content.Types.Contains( metadataClass.BaseClass ) )
					DependsOnFiles.Add( metadataClass.BaseClass.Parent.Parent );
			}

			foreach( Member m in metadataClass.Members )
			{
				metadata.Type valueType = null;
				if ( m is Collection )
					valueType = (m as Collection).Type;
				if ( m is FileStorage )
					valueType = (m as FileStorage).Type;
				if ( m is Value )
					valueType = (m as Value).Type;

				if ( valueType != null && !File.Content.Types.Contains( valueType ) )
					DependsOnFiles.Add( valueType.Parent.Parent );					
			}
		}
		foreach( MetadataFile metadataFile in DependsOnFiles )
		{
#>
#include "<#= File.RelativePathFor( metadataFile ) + metadataFile.Name #>.h"
<#+
		}
		WriteLine("");
#>
// forward declarations

<#+
		string qualifiedNamespaceBegin = File.QualifiedNamespaceBegin;
		if ( qualifiedNamespaceBegin.Length > 0 )
		{
			WriteLine( qualifiedNamespaceBegin );
			PushIndent("\t");		
		}
		foreach( MetadataClass metadataClass in File.Content.Classes )
		{
			if ( metadataClass is CollectionClass )
				continue;
				
			if ( metadataClass.Namespace.Length > 0 )
			{
				WriteLine( "namespace " + metadataClass.Namespace );
				WriteLine( "{" );
				PushIndent("\t");
			}
#>
class <#=metadataClass.TypeName#>;
<#+
			if ( metadataClass.UserDefined )
			{
#>
class <#=metadataClass.TypeName#>_Boxed;
<#+
			}
			if ( metadataClass.Namespace.Length > 0 )
			{
				PopIndent();
				WriteLine( "}" );
			}
		}
		string qualifiedNamespaceEnd = File.QualifiedNamespaceEnd;
		if ( qualifiedNamespaceEnd.Length > 0 )
		{
			PopIndent();
			WriteLine( "}" );
		}
		
		WriteLine( "" );
		
		if ( qualifiedNamespaceBegin.Length > 0 )
		{
			WriteLine( qualifiedNamespaceBegin );
			PushIndent("\t");
			WriteLine( "" );
		}

		// ENUMS

		foreach( Enumeration e in File.Content.Enumerations )
		{
			if ( e.Namespace.Length > 0 )
			{
				WriteLine( "namespace " + e.Namespace );
				WriteLine( "{" );
				PushIndent("\t");
			}
#>
namespace <#=e.TypeName#>
{
	enum Enum
	{
<#+
			foreach ( Enumerator enumerator in e.Enumerators )
				WriteLine( "\t\t" + enumerator.Name + " = " + enumerator.IntegralValue + "," );
#>		Num<#=e.TypeName#>s
	};
}

class <#=e.TypeName#>_Boxed : public core::DataObject
{
public:
	<#=e.TypeName#>::Enum value;
};

<#+
			if ( e.Namespace.Length > 0 )
			{
				PopIndent();
				WriteLine( "} // namespace " + e.Namespace );
			}
		}
#>
// classes

<#+
		/// CLASSES
		
		foreach( MetadataClass c in File.Content.ClassesSorted )
		{
			if ( c.Namespace.Length > 0 )
			{
				WriteLine( "namespace " + c.Namespace );
				WriteLine( "{" );
				PushIndent("\t");
			}

			if ( c is CollectionClass )
			{
				CollectionClass collectionClass = c as CollectionClass;
#>
typedef Oz::DArray<<#=collectionClass.ItemsClass.QualifiedTypeNameCpp#>> <#=c.TypeName#>;

<#+
			}

			if ( !c.UserDefined && ! (c is CollectionClass) )
			{
				string baseDeclaration = "core::DataObject";
				if ( c.IsReferenced || c is FolderClass || c is FileClass )
					baseDeclaration = "core::ReferenceObject";

				if ( c.BaseClass != null )
				{
					if ( c.BaseClass.QualifiedNamespace == c.QualifiedNamespace )
						baseDeclaration = c.BaseClass.TypeName;
					else
						baseDeclaration = c.BaseClass.QualifiedTypeNameCpp;
				}
#>			
class <#=CppClassesQualifier#><#=c.TypeName#> : public <#=baseDeclaration#>
{
	RTTI(<#=c.TypeName#>);

public:
	<#=c.TypeName#>();
	~<#=c.TypeName#>();
<#+
				if ( !c.Members.Empty )
					WriteLine("");
				PushIndent("\t");
				foreach( Member m in c.Members )
				{
					if ( m is Collection )
					{
						Collection collection = (Collection)m;
#>
<#=collection.Type.QualifiedTypeNameCpp#> <#=m.Name#>;
<#+
					}
					else if ( m is FileStorage )
					{
						FileStorage fileStorage = (FileStorage)m;
#>
<#=fileStorage.Type.QualifiedTypeNameCpp#> * <#=m.Name#>;
<#+
					}
					else if ( m is ParentReference )
					{
						ParentReference parentReference = (ParentReference)m;
#>
<#=parentReference.Type.QualifiedTypeNameCpp#> * <#=m.Name#>;
<#+
					}
					else if ( m is Reference )
					{
						Reference reference = (Reference)m;
						if ( !reference.Type.IsReferenced )
							TextTransformation.Error( "Can't generate reference " + m.Name + " to non-referenced type " + reference.Type.QualifiedTypeNameCpp );			
#>
<#=reference.Type.QualifiedTypeNameCpp#> * <#=m.Name#>;
<#+
					}
					else if ( m is Value )
					{
						Value value = (Value)m;
						if ( value.Type is Fundamental )
						{
#>
<#=value.Type.QualifiedTypeNameCpp#> <#=m.Name#>;
<#+
						}
						else if ( value.Type is Enumeration )
						{
							Enumeration enumeration = (Enumeration)value.Type;
#>
<#=value.Type.QualifiedTypeNameCpp#>::Enum <#=m.Name#>;
<#+
						}
						else if ( value.Type is MetadataClass )
						{
							MetadataClass metadataClass = (MetadataClass)value.Type;
#>
<#=value.Type.QualifiedTypeNameCpp#> <#=m.Name#>;
<#+
						}
						else
						{
							if ( value.Type == null )
								TextTransformation.Error( "Can't generate member " + c.TypeName + "." + m.Name + " with NULL type" );
							else
								TextTransformation.Error( "Can't generate member " + c.TypeName + "." + m.Name + " with unknown type " + value.Type.TypeName + " (" + value.Type.GetType().Name + ")" );
						}
					}
					else if ( m is FunctionUser )
					{
						FunctionUser functionUser = m as FunctionUser;
						WriteLine( functionUser.DeclarationWithResultCpp + ";" );
					}
				}
#>

template < typename A >
void Serialize ( A & ar )
{
<#+			
				foreach( Member m in c.Members )
				{
					if ( m is Collection )
					{
#>
	AR(<#=m.Name#>);
<#+
					}
					else if ( m is Reference )
					{
#>
	AR(<#=m.Name#>);
<#+
					}
					else if ( m is Value )
					{
#>
	AR(<#=m.Name#>);
<#+
					}
				}
#>
}
<#+			
				PopIndent();
				WriteLine( "};" ); // end of class declaration
				WriteLine( "" );
			} // !c.UserDefined
#>
namespace <#=c.TypeName#>_ByteStream
{
	bool ObjectFromByteStream( core::ByteStreamReader & stream, <#=c.QualifiedTypeNameCpp#> & dataObject );
};
<#+
			if ( c.Namespace.Length > 0 )
			{
				PopIndent();
				WriteLine( "}" );
			}
			WriteLine( "" );
			
		} // foreach( MetadataClass c in File.Content.ClassesSorted )

		if ( qualifiedNamespaceEnd.Length > 0 )
		{
			PopIndent();
			WriteLine( qualifiedNamespaceEnd );
		}

		WriteLine( "" );
		
		// ENUMS in global namespace
#>
namespace Oz
{
<#+		
		foreach( Enumeration e in File.Content.Enumerations )
		{
#>
OZ_DECLARE_ENUM_EX(<#=e.QualifiedTypeNameCpp#>::Enum, <#=e.QualifiedTypeNameCpp#>::Num<#=e.TypeName#>s, <#=CppClassesQualifier#>);
<#+
		}
#>
} // namespace Oz

#endif // <#=File.RelativeName.Replace( @"\", "_" )#>_UcDb_h
<#+
		return this.GenerationEnvironment.ToString();
	}
} // UcDbHppFileGeneration
#>
<#+
public class UcDbCppFileGeneration : Template
{
	protected GeneratedTextTransformation		TextTransformation;
	protected metadata.MetadataProject			Project;
	protected string							CppClassesQualifier;
	protected metadata.MetadataFile				File;
	
	public UcDbCppFileGeneration( GeneratedTextTransformation textTransformation, metadata.MetadataProject project, string cppClassesQualifier, metadata.MetadataFile file )
	{
		TextTransformation = textTransformation;
		Project = project;
		CppClassesQualifier = cppClassesQualifier;
		File = file;
	}
	
	public override string TransformText()
	{
#>

// AUTOGENERATED FILE. MODIFY IT AT YOUR OWN RISK.

#include "<#=File.Name#>.h"

namespace Oz
{
<#+
		// ENUMS

		foreach( Enumeration e in File.Content.Enumerations )
		{
			if ( e.Namespace.Length > 0 )
			{
				WriteLine( "namespace " + e.Namespace );
				WriteLine( "{" );
				PushIndent("\t");
			}
#>
const EnumBase::Name Enum< <#=e.QualifiedTypeNameCpp#>::Enum >::Names[] =
{
<#+
			foreach ( Enumerator enumerator in e.Enumerators )
			{
#>
	{"<#=enumerator.Name#>", <#=e.QualifiedTypeNameCpp#>::<#=enumerator.Name#> },
<#+
			}
#>
	{0,	<#=e.QualifiedTypeNameCpp#>::Num<#=e.TypeName#>s}
};

<#+
			if ( e.Namespace.Length > 0 )
			{
				PopIndent();
				WriteLine( "} // namespace " + e.Namespace );
			}
		}
#>
} // namespace Oz

<#+
		string qualifiedNamespaceBegin = File.QualifiedNamespaceBegin;
		if ( qualifiedNamespaceBegin.Length > 0 )
		{
			WriteLine( qualifiedNamespaceBegin );
			WriteLine( "" );
		}

		// CLASSES

		foreach( MetadataClass c in File.Content.Classes )
		{
			if ( c.Namespace.Length > 0 )
			{
				WriteLine( "namespace " + c.Namespace );
				WriteLine( "{" );
				WriteLine( "" );
			}
#>
bool <#=c.TypeName#>_ByteStream::ObjectFromByteStream( core::ByteStreamReader & stream, <#=c.QualifiedTypeNameCpp#> & dataObject )
{
<#+
				foreach( Member m in c.Members )
				{
					if ( m is Value )
					{
						Value value = (Value)m;
						if ( value.Type is Fundamental )
						{
							if ( value.Type is FundamentalByte )
							{
#>
	core::uint8 <#=value.Name#>; if ( !stream.ReadUint8( <#=value.Name#> ) ) return false;
<#+
							}
							else if ( value.Type is FundamentalBool )
							{
#>
	core::uint8 <#=value.Name#>_Byte; if ( !stream.ReadUint8( <#=value.Name#>_Byte) ) return false;
	<#=value.Type.QualifiedTypeNameCpp#> <#=value.Name#> = !!<#=value.Name#>_Byte;
<#+
							}
							else if ( value.Type is FundamentalInt )
							{
#>
	<#=value.Type.QualifiedTypeNameCpp#> <#=value.Name#>; if ( !stream.ReadInt32( <#=value.Name#> ) ) return false;
<#+
							}
							else if ( value.Type is FundamentalString )
							{
#>
	core::uint32 <#=value.Name#>_Size; if ( !stream.ReadSize( <#=value.Name#>_Size ) ) return false;
	void const * <#=value.Name#>_Bytes; if ( !stream.ReadBytes( <#=value.Name#>_Size, <#=value.Name#>_Bytes ) ) return false;
	<#=value.Type.QualifiedTypeNameCpp#> <#=value.Name#> ( (char*)<#=value.Name#>_Bytes, <#=value.Name#>_Size );
<#+
							}
							else if ( value.Type is FundamentalFloat )
							{
#>
	<#=value.Type.QualifiedTypeNameCpp#> <#=value.Name#>; if ( !stream.ReadFloat32( <#=value.Name#> ) ) return false;
<#+
							}
						}
						else if ( value.Type is Enumeration )
						{
#>
	<#=value.Type.QualifiedTypeNameCpp#>::Enum <#=value.Name#>; if ( !stream.ReadEnum( <#=value.Name#> ) ) return false;
<#+
						}
						else if ( value.Type is MetadataClass )
						{
#>
	<#=value.Type.QualifiedTypeNameCpp#> <#=value.Name#>; if ( !<#=value.Type.QualifiedTypeNameCpp#>_ByteStream::ObjectFromByteStream( stream, <#=value.Name#> ) ) return false;
<#+
						}
						
						if ( c.UserDefined )
						{
#>
	dataObject.<#=value.Name#> = <#=value.Name#>;
	
<#+
						}
						else
						{
#>
	dataObject.<#=value.Name#> = <#=value.Name#>;
	
<#+
						}
					}
				}
#>	return true;
}
<#+
			if ( c.Namespace.Length > 0 )
			{
				PopIndent();
				WriteLine( "}" );
			}			
			WriteLine( "" );

			if ( c.UserDefined )
				continue;
				
			if ( c is CollectionClass )
				continue;
				
			if ( c.Namespace.Length > 0 )
			{
				WriteLine( "namespace " + c.Namespace );
				WriteLine( "{" );
				WriteLine( "" );
			}
#>

<#=c.TypeName#>::<#=c.TypeName#>()
<#+
			PushIndent("\t");
			string separator = ":";
			foreach( Member m in c.Members )
			{				
				if ( m is Collection )
				{
					Collection collection = (Collection)m;
#>
<#=separator#> <#=m.Name#>()
<#+
				}
				else if ( m is FileStorage )
				{
#>
<#=separator#> <#=m.Name#>()
<#+
				}
				else if ( m is ParentReference )
				{
#>
<#=separator#> <#=m.Name#>()
<#+
				}
				else if ( m is Reference )
				{
#>
<#=separator#> <#=m.Name#>()
<#+
				}
				else if ( m is Value )
				{
					Value value = (Value)m;
					if ( value.Type is Fundamental )
					{
#>
<#=separator#> <#=m.Name#>(<#= value.DefaultValue.Length > 0 ? value.DefaultValue : "" #>)
<#+
					}
					else if ( value.Type is Enumeration )
					{
						Enumeration enumeration = (Enumeration)value.Type;
#>
<#=separator#> <#=m.Name#>(<#= value.DefaultValue.Length > 0 ? enumeration.QualifiedTypeNameCpp + "::" + value.DefaultValue : "" #>)
<#+
					}
					else if ( value.Type is MetadataClass )
					{
						MetadataClass metadataClass = (MetadataClass)value.Type;
						if ( value.AggregateByValue )
						{
#>
<#=separator#> <#=m.Name#>()
<#+
						}
						else if ( value.IsPolymorphic )
						{
#>
<#=separator#> <#=m.Name#>()
<#+
						}
						else
						{
#>
<#=separator#> <#=m.Name#>()
<#+
						}
					}
				}
				
				separator = ",";
			}

			PopIndent();
#>
{
<#+
			PushIndent("\t");
			foreach( Member m in c.Members )
			{
				if ( m is Value )
				{
					Value value = (Value)m;
					if ( value.Type is MetadataClass )
					{
						MetadataClass metadataClass = (MetadataClass)value.Type;
						if ( value.AggregateByValue && value.DefaultValue.Length > 0 )
						{
#>
{
<#+
							PushIndent("\t");
							foreach( Member member in metadataClass.Members )
							{
								if ( member is Value && (member as Value).Type is Fundamental )
								{
#>
<#=(member as Value).Type.QualifiedTypeNameCpp#> <#=member.Name#>; <#+
								}
							}
							WriteLine( value.DefaultValue + ";" );
							foreach( Member member in metadataClass.Members )
							{
								if ( member is Value && (member as Value).Type is Fundamental )
								{
#>
<#=m.Name#>.<#=member.Name#> = <#=member.Name#>; 
<#+
								}
							}
							PopIndent();
#>
}
<#+
						}
					}
				}
			}
			PopIndent();
#>
}

<#=c.TypeName#>::~<#=c.TypeName#>()
{
<#+
			PushIndent("\t");
			foreach( Member m in c.Members )
			{				
				if ( m is Collection )
				{
					Collection collection = (Collection)m;
#>
<#=m.Name#>.Clear();
<#+
				}
				else if ( m is FileStorage )
				{
#>
CORE_DELETE <#=m.Name#>;
<#=m.Name#> = NULL;
<#+
				}
				else if ( m is ParentReference )
				{
#>
<#=m.Name#> = NULL;
<#+
				}
				else if ( m is Reference )
				{
#>
<#=m.Name#> = NULL;
<#+
				}
				else if ( m is Value )
				{
					Value value = (Value)m;
					if ( value.Type is MetadataClass )
					{
						MetadataClass metadataClass = (MetadataClass)value.Type;
						if ( value.IsPolymorphic || !value.AggregateByValue )
						{
						}
					}
				}
			}
			PopIndent();
#>
}
<#+
			if ( c.Namespace.Length > 0 )
			{
				WriteLine( "" );
				WriteLine( "} // namespace " + c.Namespace );
			}

			WriteLine( "" );
		}

		string qualifiedNamespaceEnd = File.QualifiedNamespaceEnd;
		if ( qualifiedNamespaceEnd.Length > 0 )
		{
			WriteLine( qualifiedNamespaceEnd );
		}
	}
}
#>
