<#
	foreach( MetadataFile metadataFile in project.Metadata.FilesRecursive )
	{
		if ( metadataFile.Content != null )
		{
			foreach( MetadataClass metadataClass in metadataFile.Content.Classes )
				if ( metadataClass.Members.Find( m => m is Function && (m as Function).Remote == RemoteType.Server ) != null )
				{
					CsRemoteClientFileGeneration csFile = new CsRemoteClientFileGeneration( this, project, metadataFile );
					csFile.Output.File = metadataFile.RelativeName + ".RemoteClient.cs";
					csFile.Output.Project = csOutputProject;
					csFile.Render();
				}
		}
	}
#>
<#+
public class CsRemoteClientFileGeneration : Template
{
	protected GeneratedTextTransformation		TextTransformation;
	protected metadata.MetadataProject			Project;
	protected metadata.MetadataFile				File;
	
	public CsRemoteClientFileGeneration( GeneratedTextTransformation textTransformation, metadata.MetadataProject project, metadata.MetadataFile file )
	{
		TextTransformation = textTransformation;
		Project = project;
		File = file;
	}
	
	public override string TransformText()
	{
#>

// AUTOGENERATED FILE. MODIFY IT AT YOUR OWN RISK.

using System;
using System.Runtime.InteropServices;

<#+
		string qualifiedNamespaceBegin = File.QualifiedNamespaceBegin;
		if ( qualifiedNamespaceBegin.Length > 0 )
		{
			WriteLine( qualifiedNamespaceBegin );
			WriteLine( "" );
		}

		foreach( MetadataClass metadataClass in File.Content.Classes )
		{
			if ( metadataClass.Members.Find( m => m is Function && (m as Function).Remote == RemoteType.Server ) == null )
				continue;
		
			if ( metadataClass.Namespace.Length > 0 )
			{
				WriteLine( "namespace " + metadataClass.Namespace );
				WriteLine( "{" );
				WriteLine( "" );
			}
#>
public partial class <#=metadataClass.TypeName#>
{
<#+
			PushIndent("\t");
			foreach( Member member in metadataClass.Members )
			{
				if ( member is Function )
				{
					Function function = member as Function;
					if ( function.Remote == RemoteType.Server )
					{
#>
<#+
						string separator = "";
						metadata.Type functionResultType = null;
						if ( function.Result != null )
						{
							if ( function.Result is ArgumentReference )
								functionResultType = (function.Result as ArgumentReference).Type;
							if ( function.Result is ArgumentValue )
								functionResultType = (function.Result as ArgumentValue).Type;
						}
#>
public <#= function.IsStatic ? "static " : "" #>void <#=function.Name#> (<#+
						foreach( Argument arg in function.Arguments ) 
						{
							if ( arg is ArgumentReference )
							{
								ArgumentReference argReference = arg as ArgumentReference;
								#><#=separator#> <#= argReference.Type != null ? argReference.Type.QualifiedTypeName : "Guid"#> <#= argReference.Name #><#+
							}
							else if ( arg is ArgumentValue )
							{
								ArgumentValue argValue = arg as ArgumentValue;
								#><#=separator#> <#= argValue.Type != null ? argValue.Type.QualifiedTypeName : "byte[]"#> <#= argValue.Name #><#+
							}
							separator=",";
						} 
	#> )
{
	core.NetworkByteStreamWriter stream = new core.NetworkByteStreamWriter();
	
	stream.WriteGuid( <#=metadataClass.TypeName#>_Reflection.MetadataClass.Guid );
	stream.WriteGuid( <#=metadataClass.TypeName#>_Member_<#=function.Name#>.Member.Guid );
	stream.WriteGuid( <#= function.IsStatic ? "Guid.Empty" : "this.Guid" #> );
	
<#+
						PushIndent("\t");
						foreach( Argument arg in function.Arguments ) 
						{
							if ( arg is ArgumentReference )
							{
								ArgumentReference argReference = arg as ArgumentReference;
								if ( argReference.Type != null )
								{
#>
stream.WriteGuid( <#=argReference.Name#> != null ? <#=argReference.Name#>.Guid : Guid.Empty );
<#+
								}
								else
								{
#>
stream.WriteGuid( <#=argReference.Name#> );
<#+
								}
							}
							else if ( arg is ArgumentValue )
							{
								ArgumentValue argValue = arg as ArgumentValue;
								if ( argValue.Type == null )
								{
#>
stream.WriteBytes( <#=argValue.Name#> );
<#+
								}
								else
								{
									if ( argValue.Type is MetadataClass )
									{
#>
<#=argValue.Type.QualifiedTypeName#>_ByteStream.ObjectToByteStream( stream, <#=argValue.Name#> );
<#+
									}
									else if ( argValue.Type is Enumeration )
									{
#>
stream.WriteInt32( (int)<#=argValue.Name#> );
<#+
									}
									else if ( argValue.Type is FundamentalInt )
									{
#>
stream.WriteInt32( <#=argValue.Name#> );
<#+
									}
									else if ( argValue.Type is FundamentalFloat )
									{
#>
stream.WriteFloat32( <#=argValue.Name#> );
<#+
									}
									else if ( argValue.Type is FundamentalBool )
									{
#>
stream.WriteUint8( <#=argValue.Name#> ? (byte)1 : (byte)0 );
<#+
									}
									else if ( argValue.Type is FundamentalByte )
									{
#>
stream.WriteUint8( <#=argValue.Name#> );
<#+
									}
									else if ( argValue.Type is FundamentalString )
									{
#>
stream.WriteBytes( System.Text.Encoding.ASCII.GetBytes( <#=argValue.Name#> ) );
<#+
									}
								}
							}
						} 
						PopIndent();
#>

	<#=Project.CoreNamespace#>.remote.Client.SendToServer( stream.ToArray() );
}

<#+
					}
				}
			}
			PopIndent();
#>
};

<#+
			if ( metadataClass.Namespace.Length > 0 )
			{
				WriteLine( "" );
				WriteLine( "} // namespace " + metadataClass.Namespace );
			}

			WriteLine( "" );
		}

		string qualifiedNamespaceEnd = File.QualifiedNamespaceEnd;
		if ( qualifiedNamespaceEnd.Length > 0 )
		{
			WriteLine( qualifiedNamespaceEnd );
		}

		return this.GenerationEnvironment.ToString();
	}
}
#>
