<#
	foreach( MetadataFile metadataFile in project.Metadata.FilesRecursive )
	{
		if ( metadataFile.Content.Classes.GetEnumerator().MoveNext() )
		{
			CsByteStream classDeclaration = new CsByteStream( this, project, metadataFile );
			classDeclaration.Output.File = metadataFile.RelativeName + ".ByteStream.cs";
			classDeclaration.Output.Project = csOutputProject;
			classDeclaration.Render();
		}
	}
#>
<#+
public class CsByteStream : Template
{
	protected GeneratedTextTransformation		TextTransformation;
	protected metadata.MetadataProject			Project;
	protected metadata.MetadataFile				File;
	
	public CsByteStream( GeneratedTextTransformation textTransformation, metadata.MetadataProject project, metadata.MetadataFile file )
	{
		TextTransformation = textTransformation;
		Project = project;
		File = file;
	}
	
	public override string TransformText()
	{
#>

// AUTOGENERATED FILE. MODIFY IT AT YOUR OWN RISK.

using System;
using System.Collections.Generic;

<#+
		string qualifiedNamespaceBegin = File.QualifiedNamespaceBegin;
		if ( qualifiedNamespaceBegin.Length > 0 )
		{
			WriteLine( qualifiedNamespaceBegin );
			PushIndent("\t");
			WriteLine( "" );
		}

		foreach( MetadataClass c in File.Content.Classes )
		{
			if ( c.Namespace.Length > 0 )
			{
				WriteLine( "namespace " + c.Namespace + " {" );
				PushIndent("\t");
			}
#>
public static class <#=c.TypeName#>_ByteStream
{
	public static void ObjectToByteStream( core.ByteStreamWriter stream, <#=c.QualifiedTypeName#> dataObject ) 
	{ 
<#+
			PushIndent("\t\t");
			foreach( Member m in c.Members )
			{
				if ( m is Reference )
				{
					Reference reference = m as Reference;
#>
stream.WriteGuid( dataObject.<#=reference.Name#> != null ? dataObject.<#=reference.Name#>.Guid : Guid.Empty );
<#+
				}
				else if ( m is Value )
				{
					Value value = m as Value;
					if ( value.Type is MetadataClass )
					{
#>
<#=value.Type.QualifiedTypeName#>_ByteStream.ObjectToByteStream( stream, dataObject.<#=m.Name#> );
<#+
					}
					else if ( value.Type is Enumeration )
					{
#>
stream.WriteInt32( (int)dataObject.<#=m.Name#> );
<#+
					}
					else if ( value.Type is FundamentalInt )
					{
#>
stream.WriteInt32( dataObject.<#=m.Name#> );
<#+
					}
					else if ( value.Type is FundamentalFloat )
					{
#>
stream.WriteFloat32( dataObject.<#=m.Name#> );
<#+
					}
					else if ( value.Type is FundamentalBool )
					{
#>
stream.WriteUint8( dataObject.<#=m.Name#> ? (byte)1 : (byte)0 );
<#+
					}
					else if ( value.Type is FundamentalByte )
					{
#>
stream.WriteUint8( dataObject.<#=m.Name#> );
<#+
					}
					else if ( value.Type is FundamentalString )
					{
#>
stream.WriteBytes( System.Text.Encoding.ASCII.GetBytes( dataObject.<#=m.Name#> ) );
<#+
					}
				}
			} 
			PopIndent();
#>	}		
}
<#+
			if ( c.Namespace.Length > 0 )
			{
				PopIndent();
				WriteLine( "} // namespace " + c.Namespace );
			}

			WriteLine( "" );
		}

		string qualifiedNamespaceEnd = File.QualifiedNamespaceEnd;
		if ( qualifiedNamespaceEnd.Length > 0 )
		{
			PopIndent();
			WriteLine( qualifiedNamespaceEnd );
		}

		return this.GenerationEnvironment.ToString();
	}
}
#>

