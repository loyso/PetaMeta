<#
	foreach( MetadataFile metadataFile in project.Metadata.FilesRecursive )
	{
		if ( metadataFile.Content.Classes.GetEnumerator().MoveNext() )
		{
			CsPartial classDeclaration = new CsPartial( this, project, metadataFile );
			classDeclaration.Output.File = metadataFile.RelativeName + ".cs";
			classDeclaration.Output.Project = csOutputProject;
			classDeclaration.Render();
		}
	}
#>
<#+
public class CsPartial : Template
{
	protected GeneratedTextTransformation		TextTransformation;
	protected metadata.MetadataProject			Project;
	protected metadata.MetadataFile				File;
	
	public CsPartial( GeneratedTextTransformation textTransformation, metadata.MetadataProject project, metadata.MetadataFile file )
	{
		TextTransformation = textTransformation;
		Project = project;
		File = file;
	}
	
	public override string TransformText()
	{
#>

// AUTOGENERATED FILE. MODIFY IT AT YOUR OWN RISK.

using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;

<#+
		string qualifiedNamespaceBegin = File.QualifiedNamespaceBegin;
		if ( qualifiedNamespaceBegin.Length > 0 )
		{
			WriteLine( qualifiedNamespaceBegin );
			PushIndent("\t");
			WriteLine( "" );
		}

		foreach( Fundamental fundamental in File.Content.Fundamentals )
		{
			if ( fundamental.Namespace.Length > 0 )
				WriteLine( "namespace " + fundamental.Namespace + "{" );
#>
public class <#=fundamental.TypeName#>_Boxed : core.FundamentalBoxed
{
	public <#=fundamental.TypeName#> value;
}

<#+
			if ( fundamental.Namespace.Length > 0 )
				WriteLine( "}" );
		}

		foreach( Enumeration e in File.Content.Enumerations )
		{
			if ( e.Namespace.Length > 0 )
			{
				WriteLine( "namespace " + e.Namespace );
				WriteLine( "{" );
				PushIndent("\t");
			}
			
			if ( e.Enumerators.Empty )
				TextTransformation.Error( e.TypeName + " has no enumerators" );
#>
public enum <#=e.TypeName#>
{
<#+
			foreach ( Enumerator enumerator in e.Enumerators )
				WriteLine( "\t" + enumerator.Name + " = " + enumerator.IntegralValue + "," );
#>};

public class <#=e.TypeName#>_Boxed : core.FundamentalBoxed
{
	public <#=e.TypeName#> value = <#=e.TypeName#>.<#= e.Enumerators[0].Name #>;
};

<#+
			if ( e.Namespace.Length > 0 )
			{
				PopIndent();
				WriteLine( "} // namespace " + e.Namespace );
			}
		}
		
		foreach( MetadataClass c in File.Content.Classes )
		{
			string baseDeclaration = "core.DataObject";
			string interfaceDeclaration = "";
			if ( c.IsReferenced || c is FolderClass || c is FileClass )
				baseDeclaration = "core.ReferenceObject";
			if ( c is FolderStorageClass )
				interfaceDeclaration = ", core.IFolderStorageObject";			
			if ( c is CollectionClass )
			{
				CollectionClass collectionClass = c as CollectionClass;
				if ( collectionClass.ItemsClass == null )
					TextTransformation.Error( "CollectionClass class has no ItemsClass" );
				baseDeclaration = "core.CollectionOf <" + collectionClass.ItemsClass.QualifiedTypeName + ">";
			}
			if ( c.BaseClass != null )
				baseDeclaration = c.BaseClass.QualifiedTypeName;
			if ( c.Namespace.Length > 0 )
			{
				WriteLine( "namespace " + c.Namespace );
				WriteLine( "{" );
				PushIndent("\t");
			}
			
			string classModifiers = "public";
			if ( c is AbstractClass )
				classModifiers += " abstract";
			classModifiers += " partial";
			
			WriteLine( classModifiers + " class " + c.TypeName + " : " + baseDeclaration + interfaceDeclaration );
			WriteLine( "{" );
			PushIndent("\t");
			foreach( Member m in c.Members )
			{
				if ( m is Collection )
				{
					Collection collection = (Collection)m;
#>
public <#=collection.Type.QualifiedTypeName#> <#=m.Name#> = new <#=collection.Type.QualifiedTypeName#>();
<#+
				}
				else if ( m is FileStorage )
				{
					FileStorage fileStorage = (FileStorage)m;
					WriteLine( "public " + fileStorage.Type.QualifiedTypeName + " " + m.Name + ";" );
				}
				else if ( m is ParentReference )
				{
					ParentReference parentReference = (ParentReference)m;
					WriteLine( "public " + parentReference.Type.QualifiedTypeName + " " + m.Name + ";" );
				}
				else if ( m is Reference )
				{
					Reference reference = (Reference)m;
					if ( !reference.Type.IsReferenced )
						TextTransformation.Error( "Can't generate reference " + m.Name + " to non-referenced type " + reference.Type.QualifiedTypeName );			
					WriteLine( "public " + reference.Type.QualifiedTypeName + " " + m.Name + ";" );
				}
				else if ( m is Value )
				{
					Value value = (Value)m;
					if ( value.Type is Fundamental )
					{
						Write( "public " + value.Type.QualifiedTypeName + " " + m.Name );
						if ( value.DefaultValue.Length > 0 )
							Write( " = " + value.DefaultValue );
						WriteLine(";");
					}
					else if ( value.Type is Enumeration )
					{
						Enumeration enumeration = (Enumeration)value.Type;
						Write( "public " + value.Type.QualifiedTypeName + " " + m.Name );
						if ( value.DefaultValue.Length > 0 )
							Write( " = " + enumeration.QualifiedTypeName + "." + value.DefaultValue );
						WriteLine(";");
					}
					else if ( value.Type is CollectionClass )
					{
						TextTransformation.Error( "Can't generate Value member " + c.TypeName + "." + m.Name + " with CollectionClass type " + value.Type.TypeName + " (" + value.Type.GetType().Name + ")" );
					}
					else if ( value.Type is MetadataClass )
					{
						Write( "public " + value.Type.QualifiedTypeName + " " + m.Name );
						if ( !(value.Type is AbstractClass) && !value.IsPolymorphic )
						{
							Write( " = new " + value.Type.QualifiedTypeName );
							if ( value.DefaultValue.Length > 0 )
								Write ( " {" + value.DefaultValue + "}" );
							else
								Write ( " ()" );
						}
						WriteLine(";");
					}
					else
					{
						if ( value.Type == null )
							TextTransformation.Error( "Can't generate member " + c.TypeName + "." + m.Name + " with NULL type" );
						else
							TextTransformation.Error( "Can't generate member " + c.TypeName + "." + m.Name + " with unknown type " + value.Type.TypeName + " (" + value.Type.GetType().Name + ")" );
					}
				}
			}
			
			if ( c is FileClass && c.FindBaseClass( b => b is FileClass ) == null )
			{
				Member valueName = c.FindMemberDeep( m => m is ValueName );
				Member parentFolder = c.FindMemberDeep( m => m is ParentReference && ( m as ParentReference ).Type is FolderClass );
				if ( parentFolder != null && valueName != null )
				{
#>
public string RelativeName { get { return <#=parentFolder.Name#>.RelativeName + @"\" + <#=valueName.Name#>; } }
public string FullName { get { return <#=parentFolder.Name#>.FullName + @"\" + <#=valueName.Name#>; } }
public string RootFolderRelativeName { get { return <#=parentFolder.Name#>.RootFolderRelativeName + <#=valueName.Name#>; } }
<#+
				}
			}
			
			if ( c is FolderClass && c.FindBaseClass( b => b is FolderClass ) == null )
			{
				Member parentProject = c.FindMemberDeep( m => m is ParentReference && ( m as ParentReference ).Type is ProjectClass );
				Member parentFolder = c.FindMemberDeep( m => m is ParentReference && ( m as ParentReference ).Type is FolderClass );
				Member valueName = c.FindMemberDeep( m => m is ValueName );
				if ( parentFolder != null && valueName != null )
				{
#>
public string RelativeName { get { return (<#=parentFolder.Name#> == null ? "" : <#=parentFolder.Name#>.RelativeName + @"\") + <#=valueName.Name#>; } }
public string RootFolderRelativeName { get { return <#=parentFolder.Name#> == null ? "" : <#=parentFolder.Name#>.RootFolderRelativeName + <#=valueName.Name#> + @"\"; } }
<#+
					if ( parentProject == null )
					{
#>
public string FullName { get { return <#=parentFolder.Name#>.FullName + @"\" + <#=valueName.Name#>; } }
<#+
					}
				}
				if ( parentProject != null && valueName != null )
				{
					if ( parentFolder == null )
					{
#>
public string RelativeName { get { return <#=valueName.Name#>; } }
public string RootFolderRelativeName { get { return <#=valueName.Name#> + @"\"; } }
public string FullName { get { return <#=parentProject.Name#>.ProjectPath + @"\" + <#=valueName.Name#>; } }
<#+
					}							
					else
					{
#>
public string FullName { get { return (<#=parentFolder.Name#> == null ? <#=parentProject.Name#>.ProjectPath : <#=parentFolder.Name#>.FullName ) + @"\" + <#=valueName.Name#>; } }
<#+
					}
				}

				foreach( Member m in c.Members )
				{
					if ( m is Collection )
					{
						Collection collection = m as Collection;
						CollectionClass collectionClass = collection.Type as CollectionClass;
						if ( collectionClass.ItemsClass != null && ( collectionClass.ItemsClass is FolderClass || collectionClass.ItemsClass is FileClass ) )
						{
#>

public <#=collectionClass.ItemsClass.QualifiedTypeName#> <#=collectionClass.ItemsClass.TypeName#>Create(string name)
{
	<#=collectionClass.ItemsClass.QualifiedTypeName#> collectionElement = new <#=collectionClass.ItemsClass.QualifiedTypeName#>();
<#+ 
							foreach( Member childMember in collectionClass.ItemsClass.Members )
								if ( childMember is ParentReference && (childMember as ParentReference).Type == c )
									WriteLine("\tcollectionElement." + childMember.Name + " = this;");								

							Member childValueName = collectionClass.ItemsClass.FindMemberDeep( childMember => childMember is ValueName );
							if ( childValueName != null )
								WriteLine("\tcollectionElement." + childValueName.Name + " = name;");

							if ( collectionClass.ItemsClass.IsReferenced || collectionClass.ItemsClass is FolderClass || collectionClass.ItemsClass is FileClass )
								WriteLine("\tcollectionElement.Guid = Guid.NewGuid();");
#>	
	<#=m.Name#>.Add(collectionElement);
	return collectionElement;
}
<#+
						}
					}
				}
				
				foreach( Member m in c.Members )
				{
					if ( m is Collection )
					{
						Collection collection = m as Collection;
						CollectionClass collectionClass = collection.Type as CollectionClass;
						if ( collectionClass.ItemsClass != null && ( collectionClass.ItemsClass is FolderClass || collectionClass.ItemsClass is FileClass ) )
						{
							Member childValueName = collectionClass.ItemsClass.FindMemberDeep( childMember => childMember is ValueName );
							if ( childValueName != null )
							{
#>

public <#=collectionClass.ItemsClass.QualifiedTypeName#> <#=collectionClass.ItemsClass.TypeName#>Get( string name )
{
	<#=collectionClass.ItemsClass.QualifiedTypeName#> collectionElement = <#=m.Name#>.Find( f => f.<#=childValueName.Name#> == name );
	if ( collectionElement == null )
		throw new core.TreePathException( name );
	return collectionElement;
}
<#+
							}
						}
					}
				}
			} // c is FolderClass
						
			if ( c is ProjectClass )
			{
#>
public string ProjectPath;
public string ProjectName;
<#+
			} // is ProjectClass
			
			PopIndent();
			WriteLine( "}" ); // end of class declaration

			if ( c.Namespace.Length > 0 )
			{
				PopIndent();
				WriteLine( "} // namespace " + c.Namespace );
			}

			WriteLine( "" );
		}

		string qualifiedNamespaceEnd = File.QualifiedNamespaceEnd;
		if ( qualifiedNamespaceEnd.Length > 0 )
		{
			PopIndent();
			WriteLine( qualifiedNamespaceEnd );
		}

		return this.GenerationEnvironment.ToString();
	}
}
#>

